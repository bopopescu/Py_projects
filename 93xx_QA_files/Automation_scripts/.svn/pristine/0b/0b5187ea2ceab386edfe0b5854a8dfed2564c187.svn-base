# our top level script
import os
import sys
import copy
import shutil
import Run_PKG_Installation
import Run_IQmeasure_Tests
import Run_QA
import distutils.core
import sched
import time
import mysql.connector
import traceback
import smtplib

from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

def check_package():

	print "\n ----Debug: Inside check_package()..."
	global loop_counter	
	global QA_is_running
	global New_Package_Installation
	print "\n ----Attempt counter: ", loop_counter
	# if QA is already started, then return, no need to check
	if QA_is_running:
		return
		
	#Check for the package ready here and if found do QA
	
	#Initialize all the variables to be used in code here: 
	package_type = ""
	package_name = ""
	Source_Executable_path = ""
	PKG_bin_path = ""
	#This flag acts as indicator to show if we need to Install particular package or not for QA
	#useful in case when we encounter Dongle and Lock packages, these are skipped installation
	PKG_Install_flag = True 
	
	sender = 'Silicon_Solution_QA@litepoint.com' #Email id used to send out notifications from the server
	server = '192.168.2.199' # Ip address of litepoint email server
	
	#Establish connection to the database
	# Change hostname(usually localhost), port (default=3306), username, password and name of the database based on your database and table name
	db = mysql.connector.connect(host="IQ-auto-build ", port="3306", user="lp_client", passwd="lp", db="iqautobuild") 

	# #Create cursor object to the database. It will let you execute all the query you need
	cur = db.cursor() 
		
	# SELECT Query to check new package being added to the table
	# This query sorts the result set by DESCENDING ORDER First and then pick the 1st Row only (if multiple rows are returned) WHERE TEST = '1' (indicates new package) 
	# SELECT Test, projectName, ReleaseVersion FROM buildresults WHERE projectName = 'IQmeasure' AND Test=1 ORDER BY dateTime DESC LIMIT 1;
		
	#Project_Name = 'IQmeasure' #Enter the project name here
	Test_Flag = '1' #Enter the Test ID here, default should be = 1 for new package
	PACKAGE_ID = ""
	#SELECT Query :
	SELECT_query = ("SELECT Test, projectName, ReleaseVersion, ID from buildresults WHERE projectName = %s AND Test= %s ORDER BY dateTime DESC LIMIT 1")
	# Always remember that you will need "ID" in the UPDATE clause as its the PRIMARY KEY for the buildresults table
	# UPDATE buildresults SET Test = 0 WHERE projectName = 'IQmeasure' AND ReleaseVersion = '3.0.8' AND ID = 14612
	UPDATE_query = ("UPDATE buildresults SET Test = 0 WHERE projectName = %s AND ReleaseVersion = %s AND ID = %s")
	
	#Run the SELECT query
	cur.execute(SELECT_query, (Project_Name, Test_Flag)) #execute the query
	data = cur.fetchall() #Store the result set
	
	# if loop, checking if new package is detected
	if data :
		print "\n----- Success, New package detected!!"
		# if package is ready, start QA and set flag: QA_is_running = True
		QA_is_running = True
		New_Package_Installation = True
		
		# Store the package_name
		for row in data :
			TEST_ID = row[0]
			PACKAGE_NAME = row[1] + "_" + row[2]
			Release_Version = row[2]
			PACKAGE_ID = row[3] #PrimeKey for this table, used in UPDATE Query once the package is successfully installed on the machine.
			#print PACKAGE_NAME
			if TEST_ID == '1':
				print ("\n----- New Package Name : {0} " .format(PACKAGE_NAME))
	
		pkg_name_lower = PACKAGE_NAME.lower() #convert to lower case for string comparisons

		#first check if the PACKAGE_NAME has "Dongle" or "Lock" in the name -
		if pkg_name_lower.rfind( "_lock" ) > 0 :
			PKG_Install_flag = False
			package_type = "Lock"
		elif pkg_name_lower.rfind( "_dongle" )> 0:
			PKG_Install_flag = False
			package_type = "Dongle"
		else:
			pkg_version = pkg_name_lower.rsplit(".")
			print "\n Package version: " ,pkg_version
			if len(pkg_version) == 3 :
				package_type = "release"
			elif pkg_version[len(pkg_version)-1].rfind("rc") >= 0:
				package_type = "releaseCandidate"
			elif pkg_version[len(pkg_version)-1].rfind("eng") >= 0:
				package_type = "engineeringDrop"
			else:
				package_type = "internal"

		print "\n Package installation flag : ", PKG_Install_flag		
		print "\n Package type :" ,package_type
		
		if package_flag == '1':
			if PKG_Install_flag == True: 
				print "\n -----New package, do the installation .."
				# Email notification for starting package installation, sent to station owner and jian :
				# Send the message via local SMTP server.
				session = smtplib.SMTP(server)
				# Create message container - the correct MIME type is multipart/alternative.
				msg = MIMEMultipart('alternative')
				msg['From'] = sender
				if Multiple_recipients == True :
					msg['To'] = ",".join(recipients)
				else :
					msg['To'] = recipient1
				msg['Subject'] = "QA update for station: {0}".format(package_path)
				text_PKG_found = "Hi!\nNew package has been detected.\nStarting Package installation on QA station.\nHere is the package name: {0}".format(PACKAGE_NAME)
				# Record the MIME types of both parts - text/plain and text/html.
				msg_PKG_found = MIMEText(text_PKG_found, 'plain')
				# Attach parts into message container.
				msg.attach(msg_PKG_found)
				# sendmail function takes 3 arguments: sender's address, recipient's address
				# and message to send - here it is sent as one string.
				if Multiple_recipients == True :
					print "\n Sending email from:" , sender, "to: " , recipients
					session.sendmail(sender, recipients, msg.as_string())
				else :
					print "\n Sending email from:" , sender, "to: " , recipient1
					session.sendmail(sender, recipient1, msg.as_string())
				session.quit()
				
				#call the pkg_installation script
				print "\n -----Calling Package Installation Script : Run_PKG_Installation.py "
				package_name = Run_PKG_Installation.Run( package_type, Project_Name, PACKAGE_NAME, package_path, script_path )
				print "\n -----Back to main script, Finished running of the Run_PKG_Installation.py script"	
				
				# Update the DB row for TEST_ID from '1' to '0' since package installation is done
				#Run the UPDATE query :
				print ("\n -----Updating the DATABASE once the package installation is done..")
				cur.execute(UPDATE_query, (Project_Name, Release_Version, PACKAGE_ID)) #execute the query 
				print "\t\tNumber of Row(s) updated :" +  str(cur.rowcount)
				# db.commit() #commit the Updates made to database
			else:
				print "\n -----Package type is : ", package_type
				print "\n Skipping package installation part since PKG_Install_flag is:  " ,PKG_Install_flag
				# Email notification for starting package installation, sent to station owner and jian :
				# Send the message via local SMTP server.
				session = smtplib.SMTP(server)
				# Create message container - the correct MIME type is multipart/alternative.
				msg = MIMEMultipart('alternative')
				msg['From'] = sender
				if Multiple_recipients == True :
					msg['To'] = ",".join(recipients)
				else :
					msg['To'] = recipient1
				msg['Subject'] = "QA update for station: {0}".format(package_path)
				text_PKG_found = "Hi!\nNew package has been detected.\nHere is the package name: {0} \n But, skipping Package installation since Package type is : {1}".format(PACKAGE_NAME , package_type)
				# Record the MIME types of both parts - text/plain and text/html.
				msg_PKG_found = MIMEText(text_PKG_found, 'plain')
				# Attach parts into message container.
				msg.attach(msg_PKG_found)
				# sendmail function takes 3 arguments: sender's address, recipient's address
				# and message to send - here it is sent as one string.
				if Multiple_recipients == True :
					print "\n Sending email from:" , sender, "to: " , recipients
					session.sendmail(sender, recipients, msg.as_string())
				else :
					print "\n Sending email from:" , sender, "to: " , recipient1
					session.sendmail(sender, recipient1, msg.as_string())
				session.quit()
				# Update the DB row for TEST_ID from '1' to '0' since package is Dongle or Lock
				#Run the UPDATE query :
				print ("\n -----Updating the DATABASE since the package is not to be installed..")
				cur.execute(UPDATE_query, (Project_Name, Release_Version, PACKAGE_ID)) #execute the query 
				print "\t\tNumber of Row(s) updated :" +  str(cur.rowcount)
				db.commit() #commit the Updates made to database
						
		else :
			print "\n -----Package already installed, Skipping Installation part.."
			# Email notification for PKG already present and hence skipping installation :
			# Send the message via local SMTP server.
			session = smtplib.SMTP(server)
			msg_1 = MIMEMultipart('alternative')
			msg_1['From'] = sender
			msg_1['To'] = recipient1
			msg_1['Subject'] = "QA update for station: {0}".format(package_path)
			text_PKG_Present = "Hi!\nThe package {0} is already present on QA station\nHence, Skipped package installation".format(PACKAGE_NAME)
			# Record the MIME types of both parts - text/plain and text/html.
			msg_PKG_Present = MIMEText(text_PKG_Present, 'plain')
			# Attach parts into message container.
			msg_1.attach(msg_PKG_Present)
			# sendmail function takes 3 arguments: sender's address, recipient's address
			# and message to send - here it is sent as one string.
			print "\n Sending email from:" , sender, "to: " , recipient1
			session.sendmail(sender, recipient1, msg_1.as_string())
			session.quit()
		
		if PKG_Install_flag == True: 
			# Do the QA only if the package is installed on the machine, if not then no need to do QA.
			# Email notification for PKG installation done and QA is started :
			# Send the message via local SMTP server.
			session = smtplib.SMTP(server)
			msg_2 = MIMEMultipart('alternative')
			msg_2['From'] = sender
			msg_2['To'] = recipient1
			msg_2['Subject'] = "QA update for station: {0}".format(package_path)
			text_QA_Start = "Hi!\nStarting {0} QA for the package : {1}".format(test_mode, PACKAGE_NAME)
			# Record the MIME types of both parts - text/plain and text/html.
			msg_QA_Start = MIMEText(text_QA_Start, 'plain')
			# Attach parts into message container.
			msg_2.attach(msg_QA_Start)
			# sendmail function takes 3 arguments: sender's address, recipient's address
			# and message to send - here it is sent as one string.
			print "\n Sending email from:" , sender, "to: " , recipient1
			session.sendmail(sender, recipient1, msg_2.as_string())
			session.quit()
			
			print "\n -----Calling QA Script : Run_QA.py"
			Run_QA.Run(package_name, test_mode, QA_file) #Call the QA script to perform chipset specific QA and pass the package_name & test_mode as arguments
			print "\n -----Finished QA Script.. Back to schedule_install.py script"
			
			#Commit the update for Test from '1' to '0' after successfully running Run_QA.py file & coming back to code here.
			#if the Run_QA.py throws any exception, then the update to DB won't be committed and you can still use the same script as previous with Test still '1'
			db.commit() #commit the Updates made to database
			
			# Email notification for QA done :
			# Send the message via local SMTP server.
			session = smtplib.SMTP(server)
			msg_3 = MIMEMultipart('alternative')
			msg_3['From'] = sender
			msg_3['To'] = recipient1
			msg_3['Subject'] = "QA update for station : {0}".format(package_path)
			text_QA_Finish = "Hi!\nGood News.\nFinished {0} QA for the package : {1}".format(test_mode, PACKAGE_NAME)
			# Record the MIME types of both parts - text/plain and text/html.
			msg_QA_Finish = MIMEText(text_QA_Finish, 'plain')
			# Attach parts into message container.
			msg_3.attach(msg_QA_Finish)
			# sendmail function takes 3 arguments: sender's address, recipient's address
			# and message to send - here it is sent as one string.
			print "\n Sending email from:" , sender, "to: " , recipient1
			session.sendmail(sender, recipient1, msg_3.as_string())
			session.quit()

	else :
		print "\n \t-----No package found in database currently..."
		print "\n \t-----Please wait for {0} minutes for next package detection.." .format(number_of_minutes)
	
	cur.close() #close the cursor object of database
	db.close() #close the database connection	
	
	loop_counter = loop_counter + 1
	# QA done, so reset the running flag
	QA_is_running = False
	print "\n ----Debug: Exiting check_package() function..."
	
	
try: 
	# initialize a global variable 
	QA_is_running	=	False
	# Set each check period to 30 minutes (60*30 seconds)
	number_of_minutes = 30
	#check_period = 5
	loop_counter = 1 #counter track the event counter for number of times you make a database call.
	check_period = 60 * number_of_minutes

	# check second command line argument for test mode option, e.g., "internal"
	# check third command line argument for test mode option, e.g., "sanity"
	test_mode = "full" # if the test_mode is not given on command line, by default it will be assigned to full and complete QA testing will be performed.
	global Multiple_recipients
	QA_file = "C:\\QA_files"
	os.chdir( QA_file )
	f = open("QA_config.txt", "r")
		
	for line in f:
		if 'Package_Name' in line:
			value=line.strip()
			col=value.split()
			Project_Name=col[2]
			
		elif 'QA_level' in line:
			value=line.strip()
			col=value.split()
			test_mode=col[2]
			
		elif 'Installation_type' in line:
			value=line.strip()
			col=value.split()
			package_flag=col[2]
			
		elif 'Additional_Package_Path' in line:
			value=line.strip()
			col=value.split()
			package_path=col[2]
			
		elif 'Recipient_Email_ID' in line:
			value=line.strip()
			col=value.split()
			# check if the recipient email id has more than one recipient in it. Accordingly store the values in variables to be used later on 
			if len(col) > 3 and len(col) < 6 :
				Multiple_recipients = True
				recipient1 = col[2]
				recipient2 = col[4]
				recipients = recipient1 , recipient2
				
			else :
				Multiple_recipients = False
				recipient1 = col[2]
		
		elif 'Script_path' in line: 
			value=line.strip()
			col=value.split()
			script_path = col[2]
			
	print "\n -----Project Name : ", Project_Name
	print "\n -----Test mode : ", test_mode
	print "\n -----Test flag : ", package_flag
	print "\n -----Package path : ", package_path
	print "\n -----Script path on your system: ", script_path
	if Multiple_recipients == False :
		print "\n -----recipient email id : ", recipient1
	else :
		print "\n -----recipient email ids are : ", recipient1 , recipient2
		
	if package_flag == '1':
		print "\n -----This is New Package.. As Flag = " , package_flag
	else: 
		print "\n -----Already installed Package as Flag = " , package_flag
	
	f.close()
	
	check_package() #Call the function first time before scheduling events
		
	# create a scheduler object
	#use time.time for timer units, use time.sleep for delay
	s = sched.scheduler( time.time, time.sleep )

	# Schedule the checks by calling the check_package() function every 30 minutes
	# for total of 12 hours.
	for n in range(23):
		check_time = check_period * n + check_period
		s.enter( check_time, 1, check_package, () )

	print "\n-----Debug: Calling check_package()..."
	# start the scheduler running, will wait until all events are processed

	s.run()

except: 
	print "\n -----Unexpected error:", sys.exc_info()[0],sys.exc_info()[1]
	traceback.print_exc()
	f.close() #close the text file if any exception in normal operation.
	
	#Send email notification with the error details attached in it. This helps trace the error details when there is an exception thrown on the machine for any reason
	error_details = sys.exc_info() #store the error info in a variable
	sender = 'Silicon_Solution_QA@litepoint.com'
	server = '192.168.2.199' # Ip address of litepoint email server
	# Send the message via local SMTP server.
	session = smtplib.SMTP(server)
	# Create message container - the correct MIME type is multipart/alternative.
	msg_exception = MIMEMultipart('alternative')
	msg_exception['From'] = sender
	msg_exception['To'] = recipient1
	msg_exception['Subject'] = "QA update for station : {0}".format(package_path)
	text_Exception = "Attention!!\n\nThis email is send to notify you that there is an exception thrown in the script on QA station: {0}\n\nException summary : {1}\n\nAborting the script due to this exception.. Please fix the issue and then re-run the script.".format(package_path, error_details)
	# Record the MIME types of both parts - text/plain and text/html.
	msg_error = MIMEText(text_Exception, 'plain')
	# Attach parts into message container.
	msg_exception.attach(msg_error)
	# sendmail function takes 3 arguments: sender's address, recipient's address
	# and message to send - here it is sent as one string.
	print "\n Sending email from:" , sender, "to: " , recipient1
	session.sendmail(sender, recipient1, msg_exception.as_string())
	session.quit()
	