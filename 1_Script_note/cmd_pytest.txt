#@@ 10/4/19
#@@ 11/22/19



Pytest syntax for writing tests-
1. File names should start with “test_”, or end with "_test".
2. If tests are defined as methods on a class, the class name should start with “Test".
    The class should not have an __init__ method.
3. Test method names or function names should start with “test_”.

Methods with names that don’t match this pattern won’t be executed as tests.

#@@ 1.
1)
python -m pytest -v

2) Run tests by substring matching of test method
pytest -k method2 -v

3) Run tests by markers @pytest.mark
pytest -m set1

4) parallel test
pytest -n 4 -v

5) @pytest.fixture
Fixtures can be used to share test data between tests, execute setup and teardown methods before
and after test executions respectively.

function defined in fixture will run once before each test function.

import pytest
@pytest.fixture
def get_sum_test_data():
        return [(3,5,8), (-2,-2,-4), (-1,5,4), (3,-5,-2), (0,5,5)]
def test_sum(get_sum_test_data):
        for data in get_sum_test_data:
                num1 = data[0]
                num2 = data[1]
                expected = data[2]
                assert sum(num1, num2) == expected

** Scope of fixture- Scope controls how often a fixture gets called. 
The default is function.
Here are the options for scope:
function: Run once per test
class: Run once per class of tests
module: Run once per module
session: Run once per session
autouse: default is False, if True, all the tests will run the fixture.

scope="session"If we need to perform an action before and after for a set of methods
in a folder or project we session scope (scope=“session”). 
It creates single fixture for set of methods in a project or modules in some path.

5.1) define @pytest.fixture in  conftest.py so multiple test_.py
can use it

6) Parameterized tests
@pytest.mark.parametrize("input1, input2, output",[(5,5,10),(3,5,12)])


@pytest.fixture(scope='session')
def get_sum_test_data():
        return [(3,5,8), (-2,-2,-4), (-1,5,4), (3,-5,-2), (0,5,5)]
@pytest.fixture(autouse=True)
def setup_and_teardown():
        print '\nFetching data from db'
        yield
        print '\nSaving test run data in db'
def test_sum(get_sum_test_data):
        for data in get_sum_test_data:
                num1 = data[0]
                num2 = data[1]
                expected = data[2]
                assert sum(num1, num2) == expected

7) Xfail / Skip tests

execute tests with recording either pass or fail status
@pytest.mark.xfail

completely skip test
@pytest.mark.skip

****
The builtin pytest.mark.parametrize decorator enables parametrization of arguments for a test function.
We have passed following parameters to it-
argnames — a comma-separated string denoting one or more argument names, or a list/tuple of argument strings.
Here, we have passed num1, num2 and expected as 1st input , 2nd input and expected sum respectively.
argvalues — The list of argvalues determines how often a test is invoked with different argument values.
If only one argname was specified argvalues is a list of values. If N argnames were specified,
argvalues must be a list of N-tuples, where each tuple-element specifies a value for its respective argname.
Here, we have passed a tuple of (3,5,8) inside a list where 3 is num1,5 isnum2 and 8is expected sum.

@pytest.mark.parametrize('num1, num2, expected',[(3,5,8), (-2,-2,-4), (-1,5,4), (3,-5,-2), (0,5,5)])
def test_sum(num1, num2, expected):
        assert sum(num1, num2) == expected

In above code, we have passed the values of 2nd argument(which are actual test data) directly there.
We can also make a function call to get those values.
import pytest
def get_sum_test_data():
        return [(3,5,8), (-2,-2,-4), (-1,5,4), (3,-5,-2), (0,5,5)]
@pytest.mark.parametrize('num1, num2, expected',get_sum_test_data())
def test_sum(num1, num2, expected):
        assert sum(num1, num2) == expected
_____________________________________________________
Summary

Install pytest using pip install pytest=2.9.1
Simple pytest program and run it with py.test command.
Assertion statements, assert x==y, will return either True or False.
How pytest identifies test files and methods.
Test files starting with test_ or ending with _test
Test methods starting with test
py.test command will run all the test files in that folder and subfolders. To run a specific file, we can use the command py.test <filename>
Run a subset of test methods
Grouping of test names by substring matching.

py.test -k <name> -v will run all the tests having <name> in its name.

Run test by markers.Mark the tests using @pytest.mark.<name> and run the tests using
pytest -m <name> to run tests marked as <name>.
@pytest.mark.set2
def test_file1_method1():
    x, y = 5, 6
    assert x+1 == y, "x + 1 == y failed"
    #assert x == y, "x==y failed"
    assert x == y, "test failed because x=" + str(x) + " y=" + str(y)
python -m pytest -m set1


Run tests in parallel
Install pytest-xdist using pip install pytest-xdist
Run tests using py.test -n NUM where NUM is the number of workers

Creating fixture methods to run code before every test by marking the method with @pytest.fixture
The scope of a fixture method is within the file it is defined.
A fixture method can be accessed across multiple test files by defining it in conftest.py file.
A test method can access a fixture by using it as an input argument.
Parametrizing tests to run it against multiple set of inputs.

@pytest.mark.parametrize("input1, input2, output",[(5,5,10),(3,5,12)]) def test_add(input1, input2, output):
assert input1+input2 == output,"failed"
will run the test with inputs (5,5,10) and (3,5,12)
Skip/xfail tests using @pytets.mark.skip and @pytest.mark.xfail
Create test results in XML format which covers executed test details using py.test test_sample1.py -v --junitxml="result.xml"
A sample pytest framework to test an API
___________________________________________________________

# keyword expressions
# Run all tests with some string ‘validate’ in the name
pytest -k “validate”
# Exclude tests with ‘db’ in name but include 'validate'
pytest -k “validate and not db”
#Run all test files inside a folder demo_tests
pytest demo_tests/

# Run a single method test_method of a test class TestClassDemo
pytest demo_tests/test_example.py::TestClassDemo::test_method
# Run a single test class named TestClassDemo
pytest demo_tests/test_example.py::TestClassDemo
# Run a single test function named test_sum
pytest demo_tests/test_example.py::test_sum
# Run tests in verbose mode:
pytest -v demo_tests/
# Run tests including print statements:
pytest -s demo_tests/
# Only run tests that failed during the last run
pytest — lf

____________________________________________________________
8) 
Coverage Test
# 
pip install coverage
coverage run test.py arg1 arg2
coverage report -m
coverage html

9) conftest.py

10) mock, mockito

11) examples
@pytest.fixture
def supply_AA_BB_CC():
    aa=25
    bb =35
    cc=45
    return [aa,bb,cc]


python -m pytest -v test_ex1.py -m set1
test_ex1.py::test_file1_method2 PASSED
@pytest.mark.set1
def test_file1_method2():
    x, y = 5, 6
    assert x + 1 == y, "x + 1 == y Failed"


@pytest.mark.parametrize("input1, input2, output",[(5,5,10),(3,5,12)])
def test_add(input1, input2, output):
	assert input1+input2 == output, "failed"

@pytest.mark.skip
def testadd_2():
	assert 100+200 == 300,"failed"


@pytest.mark.xfail
def testadd_3():
	assert 15+13 == 28,"failed"

12)

